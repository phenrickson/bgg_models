---
title: "Finding Board Game Neighbors"
author: "Phil Henrickson"
runtime: shiny
output: 
        html_document:
                theme: cerulean
                toc_depth: 2
                toc: TRUE #adds a Table of Contents
                toc_float: TRUE #let your ToC follow you as you scroll
                keep_md: no
                fig.caption: yes
                self_contained: yes
                mode: selfcontained
                css: styles.css
---

```{r setup, include=FALSE}

set_knitr_options()

theme_bgg = theme_bgg() +
        theme(plot.title = element_text(vjust=2))

```

```{r shiny selections and inputs}

select_data =
        shinyWidgets::radioGroupButtons(
                inputId = "data",
                label = "Select Games to Examine",
                choices = c(
                        "Upcoming Releases",
                        "Published Games"
                ),
                selected = 'Upcoming Releases',
                justified = TRUE,
                width = "400px",
                status = 'primary'
        )

datasetInput <-
        eventReactive(
                input$data,
                {
                        if (input$data == "Published Games"){
                                dataset <- training
                        }
                        else if (input$data == "Upcoming Releases"){
                                dataset <- upcoming
                        } 
                        else (
                                dataset = training
                        )
                        return(dataset)
                }
        )

select_game = 
        eventReactive(
                input$data,
                {
                        if (input$data == 'Upcoming Releases') {
                                
                                pickerInput("game",
                                            label = "Select a Game",
                                            choices = datasetInput() %>% 
                                                    pull(name),
                                            multiple = F,
                                            options = pickerOptions(container = "body",
                                                                    liveSearch = TRUE,
                                                                    style = "btn-primary"),
                                            width = "100%",
                                            choicesOpt = list(
                                                    subtext =
                                                            paste(
                                                                    paste(
                                                                            "published:",
                                                                            datasetInput() %>%
                                                                                    pull(yearpublished),
                                                                            sep = " | "
                                                                    )
                                                            )
                                            )
                                )
                        }
                        
                        else {
                                
                                pickerInput("game",
                                            label = "Select a Game",
                                            choices = datasetInput() %>% 
                                                    pull(name),
                                            multiple = F,
                                            options = pickerOptions(container = "body",
                                                                    liveSearch = TRUE,
                                                                    style = "btn-primary"),
                                            width = "100%",
                                            choicesOpt = list(
                                                    subtext =
                                                            paste(
                                                                    paste(
                                                                            "published:",
                                                                            datasetInput() %>%
                                                                                    pull(yearpublished),
                                                                            paste(
                                                                                    "bgg rank:",
                                                                                    1:nrow(datasetInput())
                                                                            ),
                                                                            sep = " | "
                                                                    )
                                                            )
                                            )
                                            
                                )
                        }
                },
                ignoreNULL = FALSE
        )

# get id of selected game
selected_game_id = 
        eventReactive(
                input$game,
                {
                        compare_games %>%
                                find_game_id(
                                        search = input$game
                                )
                }
        )

# get name of selected game
selected_name = 
        # eventReactive(
        #         input$data,
        reactive(
                {
                        compare_games %>%
                                filter(game_id == selected_game_id()) %>%
                                pull(name)
                }
        )

```


# What is this?

This report allows users to analyze upcoming and historical board games from [BoardGameGeek (BGG)](boardgamegeek.com). Which games are similar to each other? 
Which upcoming game are expected to be highly rated/popular? 

For any given game, I predict its expected BGG ratings using predictive models trained on historical data from BGG. I then search for the game's nearest neighbors on BGG - looking games that have similar information, such as mechanics, categories and complexity. Games that are close to each other are said to be neighbors.

## Selections

First, select whether you want to examine upcoming or newly released games (published prior to **`r end_train_year`**), or whether you want to examine games that have already been published.

```{r}

# display options for data and game
renderUI({
        fluidRow(
                column(
                        width = 4,
                        select_data
                )
        )
})

```

Next, select a game to examine its predicted ratings and nearest neighbors on BGG. Upcoming releases are sorted by expected geek rating, while published games are sorted based on their current geek rating.

```{r}

# display options for data and game
renderUI({
        fluidRow(
                    column(
                        width = 4,
                        select_game()
                )
        )
})

```

```{r selections for finding neighbors}

# button to initiate new neighbor search
input_button = 
        actionButton("submit_neighbors",
                     label = "Update Number",
                     style='padding:20px; font-size:90%')

# select metric
select_metric = 
        pickerInput("metric",
                    label = 'Distance Metric',
                    choices = c("euclidean",
                                "manhattan",
                                "angular",
                                "canberra",
                                "correlation"
                                #    "hamming"
                    ),
                    multiple = F,
                    selected = c("canberra"),
                    options = pickerOptions(
                            container = "body",
                            style = "btn-primary"
                    )
        )

select_neighbors = 
        sliderTextInput(
                "top_neighbors",
                label = "Number of Neighbors:",
                choices = c(5, 10, 15, 25, 50, 100, 250),
                grid =F,
                selected = 15
        )
        # numericInput("top_neighbors",
        #              label = 'Number of Neighbors:',
        #              15,
        #              min = 1,
        #              max = 100)

select_contributors = 
        numericInput("top_contributors",
                     label = 'Select Number of Features:',
                     10,
                     min = 5,
                     max = 100)

selected_top_neighbors = 
        eventReactive(
                input$submit_neighbors,
                {
                        input$top_neighbors +1
                },
                ignoreNULL = FALSE
        )

selected_top_contributors = 
        eventReactive(
                input$submit_neighbors,
                {
                        input$top_contributors + 1
                },
                ignoreNULL = FALSE
        )

selected_metric = 
        eventReactive(
                input$submit_neighbors,
                {
                        input$metric
                },
                ignoreNULL = FALSE
        )

# find neighbors
game_neighbors = 
        reactive({
                compare_games %>%
                        filter(game_id == selected_game_id() |
                                       yearpublished <= end_train_year 
                        ) %>%
                        find_game_neighbors(
                                game_id = selected_game_id(),
                                metric = input$metric
                        )
        })

# neighbor ids
selected_neighbors = 
        reactive({
                game_neighbors() %>%
                        pull(neighbor_id) %>%
                        head(selected_top_neighbors())
        })

```

```{r game profile}


# make game profile table
render_gt({
        games %>%
                filter(game_id == selected_game_id()) %>%
                make_game_profile_gt() %>%
                tab_options(
                        table.background.color = 'grey100',
                        table.font.size = 16,
                        heading.align = "left",
                        column_labels.border.top.style = "none", 
                        table.border.top.style = "none",
                        column_labels.border.bottom.style = "none", 
                        column_labels.border.bottom.width = 1,
                        column_labels.border.bottom.color = "#334422", 
                        table_body.border.top.style = "none", 
                        table_body.border.bottom.color = "white",
                        heading.border.bottom.style = "none",
                        data_row.padding = px(7)
                )
})

# game categories
render_gt({
        games %>%
                filter(game_id == selected_game_id()) %>%
                make_game_categories_gt() %>%
                tab_options(
                        table.font.size = 14,
                        heading.align = "left",
                        column_labels.border.top.style = "none", 
                        table.border.top.style = "none",
                        column_labels.border.bottom.style = "none", 
                        column_labels.border.bottom.width = 1,
                        column_labels.border.bottom.color = "#334422", 
                        table_body.border.top.style = "none", 
                        table_body.border.bottom.color = "white",
                        heading.border.bottom.style = "none",
                        data_row.padding = px(7),
                        container.height = 250
                )
})

```

<!-- ## Visualizations -->

```{r viz}

# renderPlot({
#         gridExtra::grid.arrange(
#                 averageweight_plot %>%
#                         add_game_highlight(
#                                 game_ids = selected_game_id()),
#                 usersrated_plot %>%
#                         add_game_highlight(
#                                 game_ids = selected_game_id()),
#                 ncol = 2
#         )
# })

# renderPlotly({
#         average_plot %>%
#                 add_trace_games(
#                         game_ids = input$game
#                 )
# })

# # complexity vs average
# renderPlotly({
#         plot_data %>%
#                 make_average_plot() %>%
#                 add_trace_games(game_ids = selected_neighbors()$neighbor_id[1],
#                                 color = 'blue',
#                                 ax = 10,
#                                 ay = -30,
#                                 trace_label = 'Game')
# })

# # average vs usersrated
# renderPlotly({
#         plot_data %>%
#                 make_usersrated_plot() %>%
#                 add_trace_games(game_ids = selected_neighbors()$neighbor_id[1],
#                                 color = 'blue',
#                                 ax = 20,
#                                 ay = -20,
#                                 trace_label = 'Game')
#         
# })


```

# Predictions

This table displays my model's **estimated** values for the game's BGG ratings (Geek Rating, Average Weight, Average Rating, and User Ratings) next to the game's **current** ratings on BGG. 

```{r}

prediction =
        reactive({
                games_predicted %>%
                        filter(game_id == selected_game_id())
        })

estimates_gt =
        reactive({
                prediction() %>%
                        make_game_estimates_gt_table(
                                id = selected_game_id()
                        )
        })

estimates_header = 
        reactive({
                if (input$data == 'Upcoming Releases') {
                        
                        estimates_gt() %>%
                                tab_header(
                                        title = paste(selected_name(), selected_game_id())
                                )
                }
                else if (input$data == 'Published Games') {
                        
                        estimates_gt() %>%
                                tab_header(
                                        title = paste0(paste(selected_name(), selected_game_id()), "*")
                                )
                }
        })

render_gt({
        estimates_header() %>%
                cols_move_to_start("Geek Rating") %>%
                tab_options(heading.title.font.size = 16,
                            table.font.size = 14,
                            heading.align = "left",
                            column_labels.border.top.style = "none", 
                            table.border.top.style = "none",
                            column_labels.border.bottom.style = "none", 
                            column_labels.border.bottom.width = 1,
                            column_labels.border.bottom.color = "#334422", 
                            table_body.border.top.style = "none", 
                            table_body.border.bottom.color = "white",
                            heading.border.bottom.style = "none",
                            data_row.padding = px(7)
                )
})

```


I trained predictive models on historical games in order to estimate how the BGG community is likely to rate upcoming games. These models were trained on games published prior to **`r end_train_year + 1`** and make use of information about the game that is available *at release*, such as playing time, player count, mechanics, categories, as well as selected artists, designers, and publishers.

<!-- To estimate the Geek Rating, I first estimate the how complex the BGG community is likely to rate the game (Average Weight). I then use the estimated complexity alongside other features to estimate the game's average rating and number of user ratings. I then combine these estimates in BGG's Geek Rating formula (a form of Bayesian averaging) to produce an estimate for the game's Geek Rating. -->

*When examining historical games that have already been released, I report the model's predictions, but these games are in the training set. As such, the model will have already seen these games, and the estimates will have lower error than we would expect for upcoming games.

## Explaining Predictions

Why are some games predicted to have higher average ratings but not others? What goes into these estimates?

The following visualizations uses [Shapley values](https://shap.readthedocs.io/en/latest/example_notebooks/overviews/An%20introduction%20to%20explainable%20AI%20with%20Shapley%20values.html) to indicate which features were most influential for the model’s predictions. Anything in blue increased the model’s predictions; anything in red decreased the model’s predictions.

```{r shapley}

renderPlot({
        map2_df(.x = selected_game_id(),
                .y = list(explain_averageweight,
                          explain_average,
                          explain_usersrated),
                ~ .y %>%
                        explain_prediction(
                                games_imputed %>%
                                        filter(game_id == .x)
                        ) %>%
                        prep_plot_explain(
                                top_n = 15
                        )
        ) %>%
                plot_explain(ncol = 2) %>%
                add_plot_explain_title(width = 70) +
                theme(strip.text.x = element_text(size = 12),
                      axis.text.y = element_text(size = 12))
},
outputArgs = list(height = "700px"))

```

# Nearest Neighbors

What games are similar to **`r reactive({selected_name()})`**? 

I compare the selected game to every other game on BoardGameGeek (published prior to `r end_train_year` based on features such mechanics, playing time, complexity, and certain game categories. The tables below display the games which had the most similar data to  `r reactive({selected_name()})`. Games that are closer in distance are said to be *neighbors*. 

```{r find neighbors}

# input panel
fluidRow(
        column(width = 4,
               select_metric),
        column(width = 4,
               select_neighbors),
        column(width = 2,
               align="center",
               input_button,
               style='padding:8px; font-size:80%')
)


# render table for neighbors
render_gt({
        game_neighbors() %>%
                make_neighbors_gt_table(
                        games = games_imputed %>%
                                left_join(.,
                                          games %>%
                                                  select(game_id, images)),
                        top_n = selected_top_neighbors()
                ) %>%
                cols_width(
                        neighbor ~ px(200)
                ) %>%
                tab_options(table.font.size = 14,
                            container.height = 600)
})

```

Note: This analysis does not look at a game’s ratings on BGG, publisher, artist, or designer - it focuses on finding similar games based on how they play, not how they are rated or by their publisher/designer.

## Similar, Highly Rated Games

What *highly rated games* are similar to **`r reactive({selected_name()})`**?

In this table I multiply every neighboring game’s similarity score by its Geek Rating. The resulting score is an attempt to balance these two quantities.

```{r}

render_gt({
        game_neighbors() %>%
                make_neighbors_rated_gt_table(
                        games = games_imputed %>%
                                left_join(.,
                                          games %>%
                                                  select(game_id, images)),
                        top_n = selected_top_neighbors()
                ) %>%
                cols_width(
                        neighbor ~ px(200)
                ) %>%
                tab_options(table.font.size = 14,
                            container.height = 600) 
        
})

```


## Examining Similarity

Why are these games similar? The following table displays features which contributed to identifying games as similar. 

```{r display features that make games similar}

games_mat = 
        reactive({
                
                compare_games %>%
                        filter(game_id %in% selected_neighbors()) %>%
                        slice(order(factor(game_id, levels = selected_neighbors()))) %>%
                        add_id() %>% 
                        make_games_matrix() 
        })

games_hclust = 
        reactive({
                
                games_mat() %>%
                        t() %>%
                        rdist(., metric = selected_metric()) %>%
                        fastcluster::hclust(method = 'complete')
        })

contributors = 
        reactive({
                games_mat()[,games_hclust()$order] %>%
                        colnames()
        })

top_contributors = 
        reactive({
                c(contributors() %>% head(10),
                  contributors() %>% tail(10) %>% rev()
                ) %>%
                        unique()
        })

pivoted = 
        reactive({
                compare_games_raw %>%
                        filter(game_id %in% selected_neighbors()) %>%
                        slice(order(factor(game_id, levels = selected_neighbors()))) %>%
                        add_id() %>%
                        select(id,
                               any_of(c(top_contributors()))
                        ) %>%
                        pivot_longer(
                                cols = -id,
                                values_to = c("value"),
                                names_to = c("feature")
                        ) %>%
                        mutate(value = case_when(feature == 'playingtime' ~ exp(value)-1,
                                                 feature == 'time_per_player' ~ exp(value)-1,
                                                 TRUE ~ value)) %>%
                        group_by(feature) %>%
                        mutate(total = sum(value)) %>%
                        filter(total != 0) %>%
                        ungroup() %>%
                        select(-total)   
        })

# renderPlot({
#         
#         compare_games_raw %>%
#                 filter(game_id %in% selected_neighbors()) %>%
#                 select(game_id, name, yearpublished, 
#                        any_of(pivoted()$feature)
#                 ) %>%
#                 add_id() %>%
#                 make_games_matrix() %>%
#                 heatmap()
#         
# })

render_gt({
        
        pivoted() %>%
                pivot_wider(
                        id_cols = "feature",
                        names_from = c("id")
                ) %>%
                mutate(feature = factor(feature, levels = top_contributors())) %>%
                mutate(dummy = case_when(
                        grepl("^mechanic", feature) ~ T,
                        grepl("^categories", feature) ~ T,
                        grepl("^families", feature) ~ T,
                        TRUE ~ F)) %>%
                mutate(feature = present_text(feature, minlength = 50)) %>%
                set_names(., str_replace(names(.), "\\s[^ ]+$", "")) %>%
                gt(
                        rowname_col = "feature"
                ) %>%
                fmt_number(drop_trailing_zeros = T) %>%
                set_gt_tab_options() %>% 
                set_gt_theme() %>%
                cols_align(columns = -"feature",
                           align = "center") %>%
                # add color to dummies
                data_color(
                        columns = where(is.numeric),
                        rows = dummy == 1,
                        colors = scales::col_numeric(
                                palette = c("white", "#3182BD"),
                                domain = c(0, 1)
                        )
                ) %>%
                # add color to numeric
                data_color(
                        direction = "row",
                        columns = where(is.numeric),
                        rows = dummy == 0,
                        palette = "Blues",
                ) %>%
                # hide
                cols_hide(
                        "dummy"
                ) %>%
                tab_options(table.font.size = 14,
                            container.height = 800)
})


```

<!-- ## Heatmap -->

<!-- We can similarly examine their profiles on principal components via hierarchical clustering. -->

<!-- ```{r heatmap} -->

<!-- renderPlot({ -->

<!--         compare_games_pca %>% -->
<!--                 filter(game_id %in% -->
<!--                                (selected_neighbors()) -->
<!--                 ) %>% -->
<!--                 plot_neighbors_heatmap( -->
<!--                         legendfun = function() heatmap3:::showLegend(legend = c(NA), -->
<!--                                                                      lwd = NA), -->
<!--                         margin = c(3, 9), -->
<!--                         col = colorRampPalette(RColorBrewer::brewer.pal(11, "RdBu"))(100), -->
<!--                         reorderfun = function(d, w) rev(reorder(d, w)) -->
<!--                 ) -->
<!-- }, -->
<!-- outputArgs = list(height = "700px")) -->

<!-- ``` -->
